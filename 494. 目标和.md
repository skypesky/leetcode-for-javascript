- 效率很低(低于95%的代码) 使用DFS算法
```ts
function findTargetSumWays(nums: number[], S: number): number {
    return dfs(nums, 0, S, 0);
};

function dfs(
    source: number[],
    currenrValue: number,
    targetValue: number,
    depth: number,
    options: number[] = [-1, 1],
): number {
    if (depth > source.length) {
        return 0;
    }
    if (depth === source.length && currenrValue === targetValue) {
        return 1;
    }
    let count = 0;
    for (const option of options) {
        const value = option * source[depth];
        currenrValue += value;
        count += dfs(source, currenrValue, targetValue, depth + 1);
        currenrValue -= value;
    }
    return count;
}
```

- 效率较高(超过65%的代码),使用hashMap
```ts
function findTargetSumWays(nums: number[], S: number): number {

    let map: Map<number, number> = new Map<number, number>();

    for (const num of nums) {
        const options: [number, number] = [-num, num];

        if (!map.size) {
            options.forEach(option => {
                option = toValue(option);
                map.set(option, (map.get(option) || 0) + 1);
            });
            continue;
        }

        map = [...map.keys()].reduce((newMap: Map<number, number>, key: number): Map<number, number> => {
            options.forEach(option => {
                let newKey: number = toValue(option + key);
                let newValue: number = (newMap.get(newKey) || 0) + map.get(key);
                newMap.set(newKey, newValue);
            });
            return newMap;
        }, new Map<number, number>());
    }

    return map.get(S) || 0;
};
// 修复-0, 0带来的差异,因为map.set(-1, 2)和map.set(1, 2)是不等价的.
function toValue(value: number): number {
    return !value ? Math.abs(value) : value;
}
```

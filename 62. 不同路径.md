# 1. 题目描述
------
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
问总共有多少条不同的路径？

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/robot_maze.png)

例如，上图是一个7 x 3 的网格。有多少可能的路径？

**示例 1:**
> 输入: m = 3, n = 2
> 输出: 3
> 解释:
> 从左上角开始，总共有 3 条路径可以到达右下角。
> 1. 向右 -> 向右 -> 向下
> 2. 向右 -> 向下 -> 向右
> 3. 向下 -> 向右 -> 向右

**示例 2:**

> 输入: m = 7, n = 3
> 输出: 28

提示：

+ 1 <= m, n <= 100
+ 题目数据保证答案小于等于 2 * 10 ^ 9


# 2. 分析
---


# 3. 代码实现
---
## 3.1 一般解法
> O(rows * cols)的空间复杂度, O(rows * cols)的时间复杂度

```javascript
/**
 * 
 * @author skypesky
 * @description 64.不同路径
 * @see: https://leetcode-cn.com/problems/unique-paths/
 * @complex O(rows * cols)的空间复杂度, O(rows * cols)的时间复杂度
 * @param {number} rows 
 * @param {number} cols
 * @return {number}
 */
var uniquePaths = function(rows, cols) {
    // 创建一个矩阵
    const mat = new Array(rows).fill((() => {
        return [];
    })());
        
    for(let row = 0; row < rows; ++row) {
        for(let col = 0; col < cols; ++col) {
            // 到达第一个节点的路径只有一条
            if(row === 0 && col === 0) {
                mat[row][col] = 1;
            } else {
                // 到达mat[row - 1][col]这个位置的路径有topValue这么多条
                let topValue = isSafeBoundary(row - 1, col, rows, cols) ? mat[row - 1][col] : 0;
                // 到达mat[row][col - 1]这个位置的路径有leftValue这么多条
                let leftValue = isSafeBoundary(row, col - 1, rows, cols) ? mat[row][col - 1] : 0;
                mat[row][col] = topValue + leftValue;
            }
        }
    }
    return mat[rows - 1][cols - 1];
};

/**
 * @description 判断(row, col)的位置是否落在矩阵 rows x cols 内,在矩阵内返回true,否则返回false.
 * @param {number} row
 * @param {number} col
 * @param {number} rows
 * @param {number} cols
 * @return {boolean} 
 */
function isSafeBoundary(row, col, rows, cols) {
    return !(row < 0 || row >= rows || col < 0 || col >= cols);
}
```
